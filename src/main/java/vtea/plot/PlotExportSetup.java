/* 
 * Copyright (C) 2020 Indiana University
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package vtea.plot;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.ArrayList;
import vtea.exploration.listeners.AxesChangeListener;
import java.awt.Color;
import java.awt.event.*;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import static java.lang.Boolean.FALSE;
import static java.lang.Boolean.TRUE;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.nio.file.Files;
import java.sql.Connection;
import java.util.HashMap;
import java.util.ListIterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import org.apache.commons.io.FilenameUtils;
import org.jfree.chart.renderer.LookupPaintScale;
import vtea._vtea;
import static vtea._vtea.LUTMAP;
import vtea.jdbc.H2DatabaseEngine;
import vtea.lut.AbstractLUT;
import vtea.exploration.listeners.CustomLutListener;
import vtea.plotprocessing.AbstractPlotMaker;
import vtea.processor.PlotProcessor;
import vteaexploration.LutCustomColorChooser;

/**
 *
 * @author sethwinfree
 */
public class PlotExportSetup extends javax.swing.JFrame implements ActionListener, CustomLutListener {

    ArrayList<AxesChangeListener> AxesChangeListeners = new ArrayList();
    ArrayList<Component> ContentList = new ArrayList();
    ArrayList<Component> LUTList = new ArrayList();
    
    ArrayList<Component>specialComponents = new ArrayList();
    HashMap<Integer, String> availableDataHM = new HashMap<Integer, String>();
    private Connection connection;
    String keySQLSafe = "";
    int explorerSelectedLutIndex = 0;
    HashMap<String, Color> customLutColors = new HashMap<String, Color>();
    LutCustomColorChooser customLutChooser;

    String filenameSource;
    String filenameDestination;
    
    String header;

    String group;
    String plotType;
    ArrayList<String> features;
    
    Object plotTypeInstance;

    JLabel dimension;
    JLabel xDimension;
    JTextField xSize;
    JLabel yDimension;
    JTextField ySize;
    JButton Go;
    JButton Close;
    
    JLabel messageLabel = new JLabel();

    /**
     * Creates new form PlotAxesSetup
     *
     * @param PosX
     * @param PosY
     */
    public PlotExportSetup() {
        initComponents();
        setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        LUT = new javax.swing.JPanel();
        Content = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Plot Settings");
        setAlwaysOnTop(true);
        setMaximumSize(new java.awt.Dimension(610, 60));
        setMinimumSize(new java.awt.Dimension(610, 60));
        setResizable(false);
        setSize(new java.awt.Dimension(610, 60));
        setType(java.awt.Window.Type.UTILITY);
        getContentPane().setLayout(new java.awt.GridBagLayout());

        LUT.setMaximumSize(new java.awt.Dimension(610, 30));
        LUT.setMinimumSize(new java.awt.Dimension(610, 30));
        LUT.setPreferredSize(new java.awt.Dimension(610, 30));

        javax.swing.GroupLayout LUTLayout = new javax.swing.GroupLayout(LUT);
        LUT.setLayout(LUTLayout);
        LUTLayout.setHorizontalGroup(
            LUTLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 610, Short.MAX_VALUE)
        );
        LUTLayout.setVerticalGroup(
            LUTLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 30, Short.MAX_VALUE)
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        getContentPane().add(LUT, gridBagConstraints);

        Content.setMaximumSize(new java.awt.Dimension(610, 30));
        Content.setMinimumSize(new java.awt.Dimension(610, 30));
        Content.setName(""); // NOI18N
        Content.setOpaque(false);
        Content.setPreferredSize(new java.awt.Dimension(610, 30));

        javax.swing.GroupLayout ContentLayout = new javax.swing.GroupLayout(Content);
        Content.setLayout(ContentLayout);
        ContentLayout.setHorizontalGroup(
            ContentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 610, Short.MAX_VALUE)
        );
        ContentLayout.setVerticalGroup(
            ContentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 30, Short.MAX_VALUE)
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        getContentPane().add(Content, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void plotChanged(String filename) {
                
        //need to do all the other stuff that changes with a new plot
        
        //1) get plottype
        //2) get group
        //3) get features
        this.filenameSource = filename;
        String csvFilename = filename.replace(".png", ".csv"); 
        
        plotType = filename.substring(0, filename.indexOf("_"));
        plotType = plotType.substring(plotType.lastIndexOf(System.getProperty("file.separator"))+1, plotType.length());
        
        

        try{
        Class<?> c;
        c = Class.forName("vtea.plotprocessing." +plotType);
        Constructor<?> con;
        Object iImp = new Object();
        con = c.getConstructor();
        iImp = con.newInstance();
        
       plotTypeInstance = iImp;

        group = ((AbstractPlotMaker) iImp).getGroup(new File(vtea._vtea.PLOT_DIRECTORY
                + System.getProperty("file.separator")
                + csvFilename));
        features = ((AbstractPlotMaker) iImp).getFeatures(new File(vtea._vtea.PLOT_DIRECTORY
                + System.getProperty("file.separator")
                + csvFilename));
        } catch (Exception ex){
            System.out.println("ERROR in plot selections...");
            ex.printStackTrace();
        }
    }
    
    private ArrayList<Component> getSecondaryComponents(String plotType){
        
        
        try{
        Class<?> c;
        c = Class.forName("vtea.plotprocessing." +plotType);
        Constructor<?> con;
        Object iImp = new Object();
        con = c.getConstructor();
        iImp = con.newInstance();
        return ((AbstractPlotMaker) iImp).getSecondarySettings(features, group, new File(filenameSource));
        } catch (Exception ex){
            System.out.println("ERROR: Getting secondary settings for, " + plotType + " : "); 
            ex.printStackTrace();
        }
        return new ArrayList<Component>();
    }

    public ArrayList<Component> buildComponents() {

        this.setTitle("Export plot");

        ArrayList<Component> comps = new ArrayList<>();
        
        dimension = new JLabel("Dimensions (in)");
        xDimension = new JLabel("X:");
        xSize = new JTextField("5");
        xSize.setPreferredSize(new Dimension(50, 25));
        yDimension = new JLabel("Y:");
        ySize = new JTextField("5");
        ySize.setPreferredSize(new Dimension(50, 25));
        Go = new JButton("Export");
        Go.setPreferredSize(new Dimension(70, 25));
        Close = new JButton("Close");
        Close.setPreferredSize(new Dimension(60, 25));

        Go.addActionListener(this);
        Close.addActionListener(this);
        
        specialComponents = this.getSecondaryComponents(plotType);

        comps.addAll(specialComponents);
        comps.add(dimension);
        comps.add(xDimension);
        comps.add(xSize);
        comps.add(yDimension);
        comps.add(ySize);
        comps.add(Go);
        comps.add(Close);

        return comps;

    }

    

    public void getPaintScale(int l) {

        String lText = "";
        if (l < 0) {
            lText = "";
        } else {
            lText = this.availableDataHM.get(l);
        }

        double max = Math.round(getMaximumOfData(H2DatabaseEngine.getColumn(vtea._vtea.H2_MEASUREMENTS_TABLE + "_" + keySQLSafe, lText), 0));
        double min = Math.round(getMinimumOfData(H2DatabaseEngine.getColumn(vtea._vtea.H2_MEASUREMENTS_TABLE + "_" + keySQLSafe, lText), 0));
        double range = max - min;
        if (max == 0) {
            max = 1;
        }

        //LookupPaintScale ps = new LookupPaintScale(min, max + 1, new Color(0x999999));
        JComboBox lutTable = (JComboBox) LUTList.get(2);
        if ("Custom LUT".equals((String) lutTable.getSelectedItem())) {

            for (int i = 0; i < customLutColors.size(); i++) {
                //ps.add(i, customLutColors.get("Cluster_" + i));
            }

        } else {
            try {
                Class<?> c;
                c = Class.forName(LUTMAP.get(lutTable.getSelectedItem().toString()));
                Constructor<?> con;

                Object iImp = new Object();

                try {

                    con = c.getConstructor();
                    iImp = con.newInstance();

                    //ps = ((AbstractLUT) iImp).getPaintScale(min, max);
                } catch (NullPointerException | NoSuchMethodException | SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
                    System.out.println("EXCEPTION: new instance decleration error... NPE etc.");
                }
            } catch (NullPointerException | ClassNotFoundException ex) {
                System.out.println("EXCEPTION: new class decleration error... Class not found.");
            }
        }

        //return ps;
    }

    public void setAdjustable(boolean state) {
        Content.setEnabled(state);
    }

    public ArrayList<Component> getSettings() {
        ArrayList<Component> al = new ArrayList();
        return al;
    }

    public void setTopPanel(ArrayList<Component> al) {
        //System.out.println("PROFILING, my current postion is: " + this.getLocation());
        //Content = new JPanel();       
        Content.setPreferredSize(new java.awt.Dimension(610, 30));
        Content.setLayout(new GridBagLayout());

        Content.removeAll();

        ContentList.clear();
        ContentList.addAll(al);

        GridBagConstraints layoutConstraints = new GridBagConstraints();

        //MethodDetail
        if (al.size() > 0) {
            layoutConstraints.fill = GridBagConstraints.EAST;
            layoutConstraints.gridx = 0;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(0), layoutConstraints);
        }
        if (al.size() > 1) {
            layoutConstraints.fill = GridBagConstraints.EAST;
            layoutConstraints.gridx = 1;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(1), layoutConstraints);
        }
        if (al.size() > 2) {
            layoutConstraints.fill = GridBagConstraints.WEST;
            layoutConstraints.gridx = 2;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(2), layoutConstraints);
        }
        if (al.size() > 3) {
            layoutConstraints.fill = GridBagConstraints.EAST;
            layoutConstraints.gridx = 3;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(3), layoutConstraints);
        }
        if (al.size() > 4) {
            layoutConstraints.fill = GridBagConstraints.WEST;
            layoutConstraints.gridx = 4;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(4), layoutConstraints);
        }
        if (al.size() > 5) {
            layoutConstraints.fill = GridBagConstraints.WEST;
            layoutConstraints.gridx = 5;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(5), layoutConstraints);
        }
        if (al.size() > 6) {
            layoutConstraints.fill = GridBagConstraints.WEST;
            layoutConstraints.gridx = 6;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(6), layoutConstraints);
        }
        if (al.size() > 7) {
            layoutConstraints.fill = GridBagConstraints.EAST;
            layoutConstraints.gridx = 7;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(7), layoutConstraints);
        }
        if (al.size() > 8) {
            layoutConstraints.fill = GridBagConstraints.HORIZONTAL;
            layoutConstraints.gridx = 8;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(8), layoutConstraints);
        }
        if (al.size() > 9) {
            layoutConstraints.fill = GridBagConstraints.WEST;
            layoutConstraints.gridx = 9;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            Content.add((Component) al.get(9), layoutConstraints);
        }

        Content.setVisible(true);
        repaint();
        pack();
    }

    public void setNewPanel(ArrayList<Component> al) {

        //Content = new JPanel();       
        LUT.setSize(new java.awt.Dimension(680, 30));
        LUT.setLayout(new GridBagLayout());

        LUT.removeAll();

        LUTList.clear();
        LUTList.addAll(al);

        GridBagConstraints layoutConstraints = new GridBagConstraints();

        //MethodDetail
        if (al.size() > 0) {
            layoutConstraints.fill = GridBagConstraints.CENTER;
            layoutConstraints.gridx = 0;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            messageLabel = new JLabel();
            messageLabel.setSize(new Dimension(300, 40));
            messageLabel.setPreferredSize(new Dimension(300, 40));
            messageLabel.setMinimumSize(new Dimension(300, 40));

            LUT.add(messageLabel, layoutConstraints);
            layoutConstraints.fill = GridBagConstraints.CENTER;
            layoutConstraints.gridx = 1;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            LUT.add((Component) al.get(0), layoutConstraints);
        }
        layoutConstraints.fill = GridBagConstraints.CENTER;
        layoutConstraints.gridx = 2;
        layoutConstraints.gridy = 0;
        layoutConstraints.weightx = 1;
        layoutConstraints.weighty = 1;
        LUT.add((Component) al.get(1), layoutConstraints);
        if (al.size() > 1) {
            layoutConstraints.fill = GridBagConstraints.HORIZONTAL;
            layoutConstraints.gridx = 3;
            layoutConstraints.gridy = 0;
            layoutConstraints.weightx = 1;
            layoutConstraints.weighty = 1;
            ((JComboBox) al.get(2)).addActionListener(this);
            LUT.add((Component) al.get(2), layoutConstraints);
        }

        ((JComboBox) LUT.getComponent(3)).setSelectedItem("Black");
        LUT.setVisible(true);

        pack();

        ((JButton) al.get(1)).addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCustomLutActionPerformed(evt);
            }
        });

        ((JComboBox) al.get(2)).addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBoxLutActionPerformed(evt);
            }
        });

        ((JButton) LUT.getComponent(2)).setEnabled(FALSE);
    }

    public void addAxesChangeListener(AxesChangeListener listener) {
        AxesChangeListeners.add(listener);
    }

    public void notifyAxesChangeListeners(ArrayList content, ArrayList LUT) {
        for (AxesChangeListener listener : AxesChangeListeners) {
            listener.onAxesSetting(content, LUT);
        }
    }




    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel Content;
    private javax.swing.JPanel LUT;
    // End of variables declaration//GEN-END:variables

    private void jComboBoxLutActionPerformed(java.awt.event.ActionEvent evt) {

        JComboBox lutChoiceComboBox = (JComboBox) evt.getSource();
        Object selectedItem = lutChoiceComboBox.getSelectedItem();

        if (selectedItem == "Custom LUT") {
            ((JButton) LUT.getComponent(2)).setEnabled(TRUE);
        } else {
            ((JButton) LUT.getComponent(2)).setEnabled(FALSE);
        }
    }

    private void jButtonCustomLutActionPerformed(java.awt.event.ActionEvent evt) {

        ArrayList<String> clusterInfo = new ArrayList<String>();

        String lText = "";
        if (explorerSelectedLutIndex < 0) {
            lText = "";
        } else {
            lText = this.availableDataHM.get(explorerSelectedLutIndex);
        }
        double max = Math.round(getMaximumOfData(H2DatabaseEngine.getColumn(vtea._vtea.H2_MEASUREMENTS_TABLE + "_" + keySQLSafe, lText), 0));
        double min = Math.round(getMinimumOfData(H2DatabaseEngine.getColumn(vtea._vtea.H2_MEASUREMENTS_TABLE + "_" + keySQLSafe, lText), 0));
        double range = max - min;
        if (max == 0) {
            max = 1;
        }

        for (int i = 0; i <= range; i++) {
            String clusterLabel = "Cluster_";
            String newClsuterLabel = clusterLabel.concat(String.valueOf(i));
            clusterInfo.add(newClsuterLabel);
        }

        customLutChooser = new LutCustomColorChooser(clusterInfo);
        customLutChooser.registerAxesSetup(this);
        customLutChooser.invokeCustomLUTWindow();

    }

    public void notifyAddFeatures(HashMap<Integer, String> availableDataHM) {
        this.availableDataHM = availableDataHM;
    }

    private double getMaximumOfData(ArrayList measurements, int l) {

        ListIterator<ArrayList> litr = measurements.listIterator();

        Number high = 0;

        while (litr.hasNext()) {
            try {

                ArrayList<Number> al = litr.next();

                if (al.get(l).floatValue() > high.floatValue()) {
                    high = al.get(l).floatValue();
                }
            } catch (NullPointerException e) {
            }
        }
        return high.longValue();

    }

    private double getMinimumOfData(ArrayList measurements, int l) {

        ListIterator<ArrayList> litr = measurements.listIterator();

        //ArrayList<Number> al = new ArrayList<Number>();
        Number low = getMaximumOfData(measurements, l);

        while (litr.hasNext()) {
            try {
                ArrayList<Number> al = litr.next();
                if (al.get(l).floatValue() < low.floatValue()) {
                    low = al.get(l).floatValue();
                }
            } catch (NullPointerException e) {
            }
        }
        //System.out.println("PROFILING: The low value is: " + low);
        return low.longValue();
        //return low.doubleValue();
    }

    public void setSettings(String keySQLSafe, String filename) {
        this.keySQLSafe = keySQLSafe;
        this.filenameSource = filename;
        plotChanged(this.filenameSource);
    }

    public void shareExplorerLutSelectedIndex(int selectedIndex) {
        this.explorerSelectedLutIndex = selectedIndex;
    }
    
    private ArrayList<ArrayList<Number>> readCSV(File file){
            
            ArrayList<ArrayList<Number>> csvData = new ArrayList();

                try {
                    int dataColumns = 0;
                BufferedReader csvReader = new BufferedReader(new FileReader(file));
                String row;
                boolean firstRow = true;
                
                header = "";


                while ((row = csvReader.readLine()) != null) {

                    firePropertyChange("method", "", "Importing CSV");
                    firePropertyChange("indeterminant", "Parsing CSV", "");

                    if (firstRow) {
                        header = row;
                        firstRow = false;
                    } else {
                        String[] data = row.split(",");

                        dataColumns = data.length;

                        ArrayList<Number> dataList = new ArrayList<Number>();

                        for (int j = 0; j < data.length; j++) {
                            dataList.add(Float.parseFloat(data[j]));
                        }

                        csvData.add(dataList);

                    }
                }
                csvReader.close();

            } catch (IOException e) {
                System.out.println("ERROR: Could not open the file.");
            }
        return csvData;
    }
    
    
    @Override
    public void onCustomLutSelection(HashMap<String, Color> customLutColors) {
        this.customLutColors = customLutColors;
    }

    @Override
    public void actionPerformed(ActionEvent e) {

        if (((JButton) e.getSource()).getText().equals("Export")) {
            int returnVal = JFileChooser.CANCEL_OPTION;
            File file = new File("Unititled");
            int choice = JOptionPane.OK_OPTION;
            do {
                JFileChooser jf = new JFileChooser(_vtea.LASTDIRECTORY);
                jf.setDialogTitle("Save plot...");

                returnVal = jf.showSaveDialog(this);

                file = jf.getSelectedFile();
                if (FilenameUtils.getExtension(file.getName()).equalsIgnoreCase("pdf")) {

                } else {
                    filenameDestination = file.toString();
                }
                if (file.exists()) {
                    String message = String.format("%s already exists\nOverwrite it?", file.getName());
                    choice = JOptionPane.showConfirmDialog(null, message, "Overwrite File", JOptionPane.OK_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE);
                }
            } while (choice != JOptionPane.OK_OPTION);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                new Thread(() -> {

                    ArrayList<String> settings = new ArrayList<>();

                    settings.add(plotType);
                    settings.add(group);
                    settings.add(filenameSource);
                    settings.add(filenameDestination);
                    
                    ArrayList<Component> specialSettings = new ArrayList<>();
                    
                    specialSettings.add(this.xSize);
                    specialSettings.add(this.ySize);
                    specialSettings.addAll(this.specialComponents);
                    PlotProcessor pp = new PlotProcessor(keySQLSafe, settings, specialSettings, features, true);
                    pp.run();

                }).start();
            }
        } else {
            this.dispose();
        }
    }

}
